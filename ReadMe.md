# Parabolaプロジェクト解説

このプロジェクトは、Unityというゲーム開発ツールを使って、物を投げたときに描く「放物線」の動きをシミュレーションする方法を学ぶためのものです。特に、放物線の動きを計算で正確に再現する方法と、物理エンジンの力を使ってより自然な動きを再現する方法の2つが紹介されています。

## このプロジェクトで学べること

* **放物線って何？**: ボールを投げたときに描く、あのきれいなカーブの正体。
* **数学と物理の力**: 放物線の動きを理解するために必要な、簡単な数学から高度な物理法則までの考え方。
* **プログラムで動きを作る**: 計算や物理エンジンを使って、ゲームの中で物を動かす仕組み。

---

## 放物線ってどんな形？（数学の視点から）

放物線は、Uの字のような形をした曲線です。例えば、噴水から出る水のしぶきや、バスケットボールをシュートしたときのボールの軌道などが放物線を描きます。数学では、`y = ax² + bx + c` という**二次関数**の式で表されるグラフが放物線になります。この式の中の `a`, `b`, `c` という数字が変わると、放物線の形や位置が変わります。

放物線には「頂点」という一番高い（または一番低い）点があり、その頂点を通る縦の線を境にして、左右がぴったり同じ形になる「対称性」という特徴があります。

---

## 物が飛ぶ動きのひみつ（物理の視点から）

私たちが物を投げると、その物は地面に落ちてきます。これは「重力」という地球が物を引っ張る力があるからです。空気の抵抗がなければ、投げられた物は必ず放物線を描いて飛んでいきます。この動きを「放物線運動」と呼びます。

物が飛ぶ速さ（速度）は、前に進む速さ（水平速度）と、上下に動く速さ（鉛直速度）に分けて考えることができます。水平速度は、空気の抵抗がなければずっと同じ速さです。でも、鉛直速度は重力の影響で常に変化します。上に飛んでいるときはだんだん遅くなり、一番高いところで一瞬止まって、その後はだんだん速くなりながら落ちていきます。

放物線運動は、この「横に一定の速さで進む動き」と「重力で上下に変化する動き」が合わさって生まれる、とても面白い現象なのです。

---

## 放物線運動の深掘り：物理法則と数学で解き明かす

放物線運動をより深く理解するために、いくつかの重要な物理法則と数学の考え方を見ていきましょう。

### 微積分で軌道を追跡する

物体の動きは**微積分**を使うと、より正確に表現できます。
* **加速度**（速度の変化率）を時間で**積分**すると**速度**がわかります。
* **速度**（位置の変化率）を時間で**積分**すると**位置**がわかります。

放物線運動では、物体に働く力は鉛直下向きの重力だけです。そのため、加速度は常に重力加速度 $g$ （約 $9.8 m/s^2$）で一定です。

* 鉛直方向の加速度: $a_y = -g$ （マイナスは下向きを表す）
* これを積分すると、時間 $t$ 後の鉛直方向の速度:  $v_y(t) = v_{y0} - gt$ （ $v_{y0}$ は最初の鉛直速度）
* さらにもう一度積分すると、時間 $t$ 後の高さ:  $y(t) = y_0 + v_{y0}t - \frac{1}{2}gt^2$ （ $y_0$ は最初の高さ）

この最後の式が、時間 $t$ の**二次関数**になっていることがわかります。これが、物体の軌道が放物線になる数学的な理由です。

### エネルギー保存の法則と位置エネルギー

空気抵抗を無視できる場合、運動する物体のエネルギーの合計は一定に保たれます。これを**エネルギー保存の法則**と呼びます。このエネルギーは主に2つの種類があります。

* **運動エネルギー ($K$)**: 物体の動きによるエネルギー。 $K = \frac{1}{2}mv^2$ で表され、**質量** $m$ と**速度** $v$ が大きいほど大きくなります。
* **位置エネルギー ($U$)**: 物体が重力に逆らって高い場所にあることで蓄えられるエネルギー。 $U = mgh$ で表され、**質量** $m$ と高さ $h$ が大きいほど大きくなります。

放物線運動中、物体は**位置エネルギー**と運動エネルギーを交換し続けています。一番高い点（頂点）では速度が最も遅くなるため運動エネルギーは最小になり、その分、**位置エネルギー**が最大になります。逆に、低い位置にあるときは速度が速くなり、運動エネルギーが大きくなります。これらの合計値は常に一定です。

### 運動量（モーメント）と速度・質量の関係

運動量（Momentum）は物体の動きの勢いを表す量で、**質量** $m$ と**速度** $v$ の積（ $p = mv$ ）で計算されます。

* **水平方向**: 何も力が働かないため、運動量は保存されます。つまり、水平方向の速度は一定です。
* **鉛直方向**: 重力という力が常に働き続けるため、運動量は変化し続けます。

ここで非常に重要なのは、空気抵抗を無視すれば、放物運動の**軌道そのものは物体の質量に依存しない**という点です。重力加速度 $g$ はすべての物体に等しく作用するため、重い鉄球も軽いボールも（真空中で投げれば）全く同じ軌道を描いて飛んでいきます。

---

## CannonLogical.cs の解説：計算で動かす大砲

`CannonLogical.cs` は、弾の動きをあらかじめ計算して、その計算通りに弾を飛ばすスクリプトです。まるで、時刻表通りに走る電車のように、決められたレールの上を正確に進みます。

### どうやって動くの？

1.  **軌道を計算**: 弾がどこからどこへ飛ぶか、一番高くなる場所はどこか、といったことを数学の計算で決めます。
2.  **レールを作る**: 計算で決めた点のつながりが、弾が通る「レール」になります。
3.  **レールの上を移動**: 弾は、このレールの上を時間に合わせて移動していきます。途中で何かにぶつかっても、レールから外れることはありません。

### どうやって着地点に到達させているの？

このスクリプトは、出発点、目標点、そして飛翔時間（または最高到達点の高さ）といった条件を使って、軌道となる**二次関数**（ $y = ax^2 + bx + c$ ）の係数 $a, b, c$ を完全に決定します。これは、**微積分**によって導かれる物理法則の数式を使い、弾がたどるべき未来の座標をすべて事前に計算しているのと同じです。このようにして作られた完璧な軌道データの上を、弾は正確に動いていくため、必ず目標の**着地点に到達できる**のです。

---

## CannonPhysical.cs の解説：物理エンジンで動かす大砲

`CannonPhysical.cs` は、Unityの「物理エンジン」という機能を使って、弾を飛ばすスクリプトです。まるで、本物の大砲のように、適切な角度と速さで弾を打ち出せば、あとは自然に目標に向かって飛んでいくイメージです。

### どうやって動くの？

1.  **初速を計算**: 弾を目標地点に届かせるために、どれくらいの速さで、どの方向に打ち出せばいいかを計算します。
2.  **物理エンジンに任せる**: 計算した初速を弾に与えると、あとは物理エンジンが重力などの影響を考えて、弾を自然に動かしてくれます。

### どうやって着地点に到達させているの？

このスクリプトの役割は、目標の**着地点に到達するために必要な「最初の速度（初速）」**を計算することだけです。この計算には、放物線運動の物理法則（**微積分**から導かれた $y = v_{y0}t - \frac{1}{2}gt^2$ などの式）が使われます。

初速が決定され、弾が打ち出された後は、Unityの物理エンジンがすべてを引き受けます。物理エンジンは、フレームごとに重力（ $-g$ ）を適用し、**エネルギー保存の法則**や**運動量の変化**といった物理法則を内部的にシミュレートします。その結果、弾は自然な放物線を描き、計算通りの着地点へと飛んでいきます。弾の**質量**は、空気抵抗や他の物体との衝突がない限り軌道に影響しませんが、物理エンジンはそういったリアルな相互作用も計算に含めることができます。

## 算出している数式の解説 
水平方向と鉛直方向の2つの物理法則の式から、着地点に到達するための時間を求める二次方程式がどのように導き出されるのか、その過程を一切省略せずに、段階的に詳しく解説します。

---

### ステップ1：2つの基本公式から始める

まず、放物線運動を支える2つの基本的な公式を準備します。

1.  **水平方向の式**: 距離 = 速度 × 時間
    * $d = V_x \cdot t$
    * $d$: 水平方向に進む距離
    * $V_x$: 水平方向の速度（一定）
    * $t$: 飛んでいる時間

2.  **鉛直方向の式**: 位置 = 初速 × 時間 - 重力による落下距離
    * $y = V_y \cdot t - \frac{1}{2}gt^2$
    * $y$: 垂直方向の高さの変化
    * $V_y$: 垂直方向の初速
    * $g$: 重力加速度

### ステップ2：初速を水平・鉛直成分に分解する

次に、発射時の合計の速さ（**初速**）を $V$、発射する角度を $\theta$ とします。この $V$ と $\theta$ を使って、$V_x$ と $V_y$ を表します。

* **水平方向の速度 ($V_x$)** は、初速 $V$ を使って次のように表せます。
    * $V_x = V \cos\theta$
* **鉛直方向の初速 ($V_y$)** は、初速 $V$ を使って次のように表せます。
    * $V_y = V \sin\theta$

これらを使って、ステップ1の2つの式を書き換えます。

* **水平方向**: $d = (V \cos\theta) \cdot t$
* **鉛直方向**: $y = (V \sin\theta) \cdot t - \frac{1}{2}gt^2$

### ステップ3：水平方向の式から時間 $t$ を取り出す

ここからが、二次方程式を導くための重要なステップです。
まず、水平方向の式 $d = (V \cos\theta) \cdot t$ から、時間 $t$ を単独で表します。

両辺を $(V \cos\theta)$ で割ると、
$t = \frac{d}{V \cos\theta}$

これで、時間を「水平距離」「初速」「発射角」で表すことができました。

### ステップ4：時間 $t$ を鉛直方向の式に代入する

次に、ステップ3で求めた $t$ の式を、鉛直方向の式 $y = (V \sin\theta) \cdot t - \frac{1}{2}gt^2$ の中に代入します。

$y = (V \sin\theta) \cdot \left(\frac{d}{V \cos\theta}\right) - \frac{1}{2}g \cdot \left(\frac{d}{V \cos\theta}\right)^2$

この式は、一見非常に複雑に見えますが、少し整理することができます。

* 1つ目の項：$\frac{V \sin\theta}{V \cos\theta} \cdot d = (\tan\theta) \cdot d$ となります。（三角関数の公式 $\tan\theta = \frac{\sin\theta}{\cos\theta}$ を使っています）
* 2つ目の項：$\frac{1}{2}g \cdot \frac{d^2}{V^2 \cos^2\theta}$ となります。

よって、式は以下のように簡潔になります。

$y = d \tan\theta - \frac{gd^2}{2V^2 \cos^2\theta}$

この式は、「**射程の公式**」として知られており、水平距離 $d$ と発射角 $\theta$ を使って、着地点の高さ $y$ を求めることができます。

### ステップ5：二次方程式の形に整理する

最後に、この射程の公式を、**発射角 $\theta$ を求めるための二次方程式**に整理します。

先ほどの式を変形します。

$\frac{gd^2}{2V^2 \cos^2\theta} = d \tan\theta - y$

ここで、三角関数の公式 $\frac{1}{\cos^2\theta} = 1 + \tan^2\theta$ を使って、式全体を $\tan\theta$ だけの式に統一します。

$\frac{gd^2}{2V^2} (1 + \tan^2\theta) = d \tan\theta - y$

この式を展開して整理すると、以下のような**$\tan\theta$についての二次方程式**が導き出されます。

$\left(\frac{gd^2}{2V^2}\right) \tan^2\theta - (d) \tan\theta + \left(y + \frac{gd^2}{2V^2}\right) = 0$

この式は、$ax^2 + bx + c = 0$ の形そのものです。

* $x$ にあたるのが $\tan\theta$
* $a$ にあたるのが $\frac{gd^2}{2V^2}$
* $b$ にあたるのが $-d$
* $c$ にあたるのが $y + \frac{gd^2}{2V^2}$

この二次方程式を解くことで、**「狙った着地点に当てるための発射角 $\theta$」**を計算できるのです。そして、この解が複数あったり、存在しなかったりするかを判断するために、**判別式**が使われます。もし判別式が負（マイナス）になれば、解が存在しない、つまりその初速では着地点に到達できないと判断できるわけです。



---

## CannonLogical.cs と CannonPhysical.cs の比較：計算か、物理エンジンか？

### 1. 動きの作り方の違い

* **`CannonLogical.cs` (計算で動かす)**:
    * 弾の飛ぶ道を、**微積分**に基づいた数学の計算で完全に決定します。まるで、あらかじめ引かれたレールの上を走る電車のように、計算通りに正確に動きます。
    * Unityの物理エンジンは使いません。スクリプトが弾の場所を細かく管理します。

* **`CannonPhysical.cs` (物理エンジンで動かす)**:
    * 弾を打ち出す**最初の速さと方向（初速）だけを計算**します。
    * 物理エンジンが、重力、**エネルギー保存**、**運動量**といった物理法則をシミュレートし、弾を自然に動かしてくれます。途中で何かに当たれば、リアルな反応を示します。

### 2. どんなときに使うのがいい？

* **`CannonLogical.cs` はこんなときに便利**:
    * 「絶対にこのレールの上を通ってほしい！」というように、弾の動きを完璧にコントロールしたいゲーム（パズルゲームなど）。
    * いつも同じ動きをさせたい、演出のための動き。

* **`CannonPhysical.cs` はこんなときに便利**:
    * 「本物みたいにリアルに動かしたい！」というゲーム（シューティングゲームなど）。
    * 弾が壁に当たって跳ね返ったり、風の影響を受けたりするような、**エネルギー保存**などが関わる自然な動きをさせたい場合。

### まとめ

`CannonLogical.cs` は「**時刻表通りに走る電車**」のように、軌道計算に基づいて正確で予測可能な動きをします。一方、`CannonPhysical.cs` は「**実際に空を飛ぶボール**」のように、現実の物理法則に従って、より自然で変化に富んだ動きをします。

どちらのスクリプトを使うかは、ゲームやアプリで「何を一番大切にしたいか」によって選びます。**計算による正確さ**か、それとも**物理シミュレーションによるリアルさ**か、それが大きな違いです。
