# Parabolaプロジェクト解説

このプロジェクトは、Unityというゲーム開発ツールを使って、物を投げたときに描く「放物線」の動きをシミュレーションする方法を学ぶためのものです。特に、放物線の動きを計算で正確に再現する方法と、物理エンジンの力を使ってより自然な動きを再現する方法の2つが紹介されています。

## このプロジェクトで学べること

* **放物線って何？**: ボールを投げたときに描く、あのきれいなカーブの正体。
* **数学と物理の力**: 放物線の動きを理解するために必要な、簡単な数学から高度な物理法則までの考え方。
* **プログラムで動きを作る**: 計算や物理エンジンを使って、ゲームの中で物を動かす仕組み。

---

## 放物線ってどんな形？（数学の視点から）

放物線は、Uの字のような形をした曲線です。例えば、噴水から出る水のしぶきや、バスケットボールをシュートしたときのボールの軌道などが放物線を描きます。数学では、`y = ax² + bx + c` という**二次関数**の式で表されるグラフが放物線になります。この式の中の `a`, `b`, `c` という数字が変わると、放物線の形や位置が変わります。

放物線には「頂点」という一番高い（または一番低い）点があり、その頂点を通る縦の線を境にして、左右がぴったり同じ形になる「対称性」という特徴があります。

---

## 物が飛ぶ動きのひみつ（物理の視点から）

私たちが物を投げると、その物は地面に落ちてきます。これは「重力」という地球が物を引っ張る力があるからです。空気の抵抗がなければ、投げられた物は必ず放物線を描いて飛んでいきます。この動きを「放物線運動」と呼びます。

物が飛ぶ速さ（速度）は、前に進む速さ（水平速度）と、上下に動く速さ（鉛直速度）に分けて考えることができます。水平速度は、空気の抵抗がなければずっと同じ速さです。でも、鉛直速度は重力の影響で常に変化します。上に飛んでいるときはだんだん遅くなり、一番高いところで一瞬止まって、その後はだんだん速くなりながら落ちていきます。

放物線運動は、この「横に一定の速さで進む動き」と「重力で上下に変化する動き」が合わさって生まれる、とても面白い現象なのです。

参考：[https://www.try-it.jp/chapters-8001/sections-8036/
](url)
---

## 放物線運動の深掘り：物理法則と数学で解き明かす

放物線運動をより深く理解するために、いくつかの重要な物理法則と数学の考え方を見ていきましょう。

### 微積分で軌道を追跡する

物体の動きは**微積分**を使うと、より正確に表現できます。
* **加速度**（速度の変化率）を時間で**積分**すると**速度**がわかります。
* **速度**（位置の変化率）を時間で**積分**すると**位置**がわかります。

放物線運動では、物体に働く力は鉛直下向きの重力だけです。そのため、加速度は常に重力加速度 $g$ （約 $9.8 m/s^2$）で一定です。

* 鉛直方向の加速度: $a_y = -g$ （マイナスは下向きを表す）
* これを積分すると、時間 $t$ 後の鉛直方向の速度:  $v_y(t) = v_{y0} - gt$ （ $v_{y0}$ は最初の鉛直速度）
* さらにもう一度積分すると、時間 $t$ 後の高さ:  $y(t) = y_0 + v_{y0}t - \frac{1}{2}gt^2$ （ $y_0$ は最初の高さ）

この最後の式が、時間 $t$ の**二次関数**になっていることがわかります。これが、物体の軌道が放物線になる数学的な理由です。

### エネルギー保存の法則と位置エネルギー

空気抵抗を無視できる場合、運動する物体のエネルギーの合計は一定に保たれます。これを**エネルギー保存の法則**と呼びます。このエネルギーは主に2つの種類があります。

* **運動エネルギー ($K$)**: 物体の動きによるエネルギー。 $K = \frac{1}{2}mv^2$ で表され、**質量** $m$ と**速度** $v$ が大きいほど大きくなります。
* **位置エネルギー ($U$)**: 物体が重力に逆らって高い場所にあることで蓄えられるエネルギー。 $U = mgh$ で表され、**質量** $m$ と高さ $h$ が大きいほど大きくなります。

放物線運動中、物体は**位置エネルギー**と運動エネルギーを交換し続けています。一番高い点（頂点）では速度が最も遅くなるため運動エネルギーは最小になり、その分、**位置エネルギー**が最大になります。逆に、低い位置にあるときは速度が速くなり、運動エネルギーが大きくなります。これらの合計値は常に一定です。

### 運動量（モーメント）と速度・質量の関係

運動量（Momentum）は物体の動きの勢いを表す量で、**質量** $m$ と**速度** $v$ の積（ $p = mv$ ）で計算されます。

* **水平方向**: 何も力が働かないため、運動量は保存されます。つまり、水平方向の速度は一定です。
* **鉛直方向**: 重力という力が常に働き続けるため、運動量は変化し続けます。

ここで非常に重要なのは、空気抵抗を無視すれば、放物運動の**軌道そのものは物体の質量に依存しない**という点です。重力加速度 $g$ はすべての物体に等しく作用するため、重い鉄球も軽いボールも（真空中で投げれば）全く同じ軌道を描いて飛んでいきます。

---

## CannonPhysical.cs の解説：物理エンジンで動かす大砲

`CannonPhysical.cs` は、Unityの「物理エンジン」という機能を使って、弾を飛ばすスクリプトです。まるで、本物の大砲のように、適切な角度と速さで弾を打ち出せば、あとは自然に目標に向かって飛んでいくイメージです。

### どうやって動くの？

1.  **初速を計算**: 弾を目標地点に届かせるために、どれくらいの速さで、どの方向に打ち出せばいいかを計算します。
2.  **物理エンジンに任せる**: 計算した初速を弾に与えると、あとは物理エンジンが重力などの影響を考えて、弾を自然に動かしてくれます。

### どうやって着地点に到達させているの？

このスクリプトの役割は、目標の **着地点に到達するために必要な「最初の速度（初速）」** を計算することだけです。この計算には、放物線運動の物理法則（ **微積分** から導かれた $y = v_{y0}t - \frac{1}{2}gt^2$ などの式）が使われます。

初速が決定され、弾が打ち出された後は、Unityの物理エンジンがすべてを引き受けます。物理エンジンは、フレームごとに重力（ $-g$ ）を適用し、**エネルギー保存の法則**や**運動量の変化**といった物理法則を内部的にシミュレートします。その結果、弾は自然な放物線を描き、計算通りの着地点へと飛んでいきます。弾の**質量**は、空気抵抗や他の物体との衝突がない限り軌道に影響しませんが、物理エンジンはそういったリアルな相互作用も計算に含めることができます。

## コードの解説
書いているコードを追って説明します。
### コードの目的：狙った場所に物を投げる

この`CalculateParabolaVelocity`関数は、指定された初速（`speed`）で、**発射地点（`start`）から着地点（`end`）に正確に届くような発射方向のベクトルを計算する**ためのものです。つまり、「どういう向きと強さで投げれば、目標に当たるか？」を物理法則に基づいて自動で導き出す役割を担っています。

### コード全体の処理の流れ

#### 1. 準備：位置と距離の計算

まず、コードは発射地点と着地点の情報を使って、いくつかの重要な数値を計算します。

* **`diff`**: 着地点（`end`）から発射地点（`start`）を引いて、2点間の**差（ベクトル）**を求めます。
* **`diffXZ`**: `diff`ベクトルから、**水平方向の成分だけ**を取り出します。これで、前後左右の移動距離がわかります。
* **`distance`**: `diffXZ`ベクトルの**長さ（大きさ）**を計算します。これが、着弾点までの水平方向の距離になります。
* **`yOffset`**: `diff`ベクトルのy成分を取り出し、**着地点と発射地点の高さの差**を計算します。
* **`g`**: `gravityY`（重力加速度）の絶対値（符号をプラスにしたもの）を取得します。

#### 2. 到達可能かを判定：二次方程式の判別式

ここがこのコードの核心です。着弾点に到達できるかどうかは、数学の**二次方程式**を使って判断します。

発射時の初速と角度、重力、そして水平・垂直の移動距離の関係から導き出される二次方程式の**判別式**を計算します。この判別式が、コード内の**`discriminant`**にあたります。

* **`discriminant = speed2 * speed2 - g * (g * distance * distance + 2 * yOffset * speed2)`**
    * この式は、投げた物体が着地点に到達するための「時間」を求める二次方程式の判別式です。

#### 3. 3つのシナリオに対応した処理

計算した`discriminant`の値に応じて、プログラムは3つの異なるシナリオに沿って動作します。

**シナリオA：到達不能な場合（`discriminant < 0`）**

* 判別式がマイナスの場合、数学的に**「実数解」が存在しません**。これは、どんな角度で投げても、この初速では目標地点まで届かないことを意味します。
* このとき、コードは「**到達不能**」と判断し、`maxAngleDeg`（事前に設定された最大の角度）を使って、最も遠くまで飛ばせるであろう方向へ発射する角度を決めます。

**シナリオB：到達可能な場合（`discriminant >= 0`）**

* 判別式がゼロ以上の場合、着弾点に到達するための「時間」が計算できることを意味します。
* このとき、多くの場合、同じ場所に当てるには**2つの異なる発射角が存在**します。一つは低い角度で素早く当たる場合（`tLow`）、もう一つは高い角度でゆっくり当たる場合（`tHigh`）です。
* `maximizeFlyTime`が`true`に設定されている場合、プログラムは`tHigh`（飛翔時間が長い方）の時間を採用します。そうでなければ、`tLow`（飛翔時間が短い方）を使います。
* この計算された時間`t`を使って、`angleRad = Mathf.Atan(1 / t)`という式から、発射に必要な角度を割り出します。

**シナリオC：発射地点と着地点がほぼ同じ場合（`distance < 0.01f`）**

* 水平距離がほぼゼロの場合、特別に「**真上に撃つ**」ことで対応します。この場合、複雑な角度計算は必要ありません。

#### 4. 最終的な発射ベクトルの生成

上記いずれかのシナリオで発射角度（`angleRad`）が決まったら、その角度を使って最終的な発射ベクトルを計算します。

* **水平方向のベクトル**: `diffXZ.normalized * speed * Mathf.Cos(angleRad)`
    * 水平方向の向き（`diffXZ.normalized`）に、水平方向の速度成分（`speed * Mathf.Cos(angleRad)`）をかけています。
* **鉛直方向のベクトル**: `velocity.y = speed * Mathf.Sin(angleRad)`
    * 鉛直方向の速度成分（`speed * Mathf.Sin(angleRad)`）をy座標に設定します。

最後に、これらの水平・鉛直の成分を組み合わせた`velocity`ベクトルを返します。このベクトルをオブジェクトの初速として与えることで、狙った場所に放物線を描いて飛んでいく動きが実現します。





---

## 算出している数式の解説 
水平方向と鉛直方向の2つの物理法則の式から、着地点に到達するための時間を求める二次方程式がどのように導き出されるのか、その過程を一切省略せずに、段階的に詳しく解説します。

---

### ステップ1：2つの基本公式から始める

まず、放物線運動を支える2つの基本的な公式を準備します。

1.  **水平方向の式**: 距離 = 速度 × 時間
    * $d = V_x \cdot t$
    * $d$: 水平方向に進む距離
    * $V_x$: 水平方向の速度（一定）
    * $t$: 飛んでいる時間

2.  **鉛直方向の式**: 位置 = 初速 × 時間 - 重力による落下距離
    * $y = V_y \cdot t - \frac{1}{2}gt^2$
    * $y$: 垂直方向の高さの変化
    * $V_y$: 垂直方向の初速
    * $g$: 重力加速度

### ステップ2：初速を水平・鉛直成分に分解する

次に、発射時の合計の速さ（**初速**）を $V$、発射する角度を $\theta$ とします。この $V$ と $\theta$ を使って、 $V_x$ と $V_y$ を表します。

* **水平方向の速度 ($V_x$)** は、初速 $V$ を使って次のように表せます。
    * $V_x = V \cos\theta$
* **鉛直方向の初速 ($V_y$)** は、初速 $V$ を使って次のように表せます。
    * $V_y = V \sin\theta$

これらを使って、ステップ1の2つの式を書き換えます。

* **水平方向**: $d = (V \cos\theta) \cdot t$
* **鉛直方向**: $y = (V \sin\theta) \cdot t - \frac{1}{2}gt^2$

### ステップ3：水平方向の式から時間 $t$ を取り出す

ここからが、二次方程式を導くための重要なステップです。
まず、水平方向の式 $d = (V \cos\theta) \cdot t$ から、時間 $t$ を単独で表します。

両辺を $(V \cos\theta)$ で割ると、
$t = \frac{d}{V \cos\theta}$

これで、時間を「水平距離」「初速」「発射角」で表すことができました。

### ステップ4：時間 $t$ を鉛直方向の式に代入する

次に、ステップ3で求めた $t$ の式を、鉛直方向の式 $y = (V \sin\theta) \cdot t - \frac{1}{2}gt^2$ の中に代入します。

$y = (V \sin\theta) \cdot \left(\frac{d}{V \cos\theta}\right) - \frac{1}{2}g \cdot \left(\frac{d}{V \cos\theta}\right)^2$

この式は、一見非常に複雑に見えますが、少し整理することができます。

* 1つ目の項： $\frac{V \sin\theta}{V \cos\theta} \cdot d = (\tan\theta) \cdot d$ となります。（三角関数の公式 $\tan\theta = \frac{\sin\theta}{\cos\theta}$ を使っています）
* 2つ目の項： $\frac{1}{2}g \cdot \frac{d^2}{V^2 \cos^2\theta}$ となります。

よって、式は以下のように簡潔になります。

$y = d \tan\theta - \frac{gd^2}{2V^2 \cos^2\theta}$

この式は、「**射程の公式**」として知られており、水平距離 $d$ と発射角 $\theta$ を使って、着地点の高さ $y$ を求めることができます。

### ステップ5：二次方程式の形に整理する

最後に、この射程の公式を、**発射角 $\theta$ を求めるための二次方程式**に整理します。

先ほどの式を変形します。

$\frac{gd^2}{2V^2 \cos^2\theta} = d \tan\theta - y$

ここで、三角関数の公式 $\frac{1}{\cos^2\theta} = 1 + \tan^2\theta$ を使って、式全体を $\tan\theta$ だけの式に統一します。

$\frac{gd^2}{2V^2} (1 + \tan^2\theta) = d \tan\theta - y$

この式を展開して整理すると、以下のような** $\tan\theta$ についての二次方程式**が導き出されます。

$\left(\frac{gd^2}{2V^2}\right) \tan^2\theta - (d) \tan\theta + \left(y + \frac{gd^2}{2V^2}\right) = 0$

この式は、 $ax^2 + bx + c = 0$ の形そのものです。

* $x$ にあたるのが $\tan\theta$
* $a$ にあたるのが $\frac{gd^2}{2V^2}$
* $b$ にあたるのが $-d$
* $c$ にあたるのが $y + \frac{gd^2}{2V^2}$

この二次方程式を解くことで、 **「狙った着地点に当てるための発射角 $\theta$ 」** を計算できるのです。そして、この解が複数あったり、存在しなかったりするかを判断するために、**判別式**が使われます。もし判別式が負（マイナス）になれば、解が存在しない、つまりその初速では着地点に到達できないと判断できるわけです。


---


## CannonLogical.cs の解説：計算で動かす大砲

`CannonLogical.cs` は、弾の動きをあらかじめ計算して、その計算通りに弾を飛ばすスクリプトです。まるで、時刻表通りに走る電車のように、決められたレールの上を正確に進みます。

### どうやって動くの？

1.  **軌道を計算**: 弾がどこからどこへ飛ぶか、一番高くなる場所はどこか、といったことを数学の計算で決めます。
2.  **レールを作る**: 計算で決めた点のつながりが、弾が通る「レール」になります。
3.  **レールの上を移動**: 弾は、このレールの上を時間に合わせて移動していきます。途中で何かにぶつかっても、レールから外れることはありません。

### どうやって着地点に到達させているの？

このスクリプトは、出発点、目標点、そして飛翔時間（または最高到達点の高さ）といった条件を使って、軌道となる**二次関数**（ $y = ax^2 + bx + c$ ）の係数 $a, b, c$ を完全に決定します。これは、**微積分**によって導かれる物理法則の数式を使い、弾がたどるべき未来の座標をすべて事前に計算しているのと同じです。このようにして作られた完璧な軌道データの上を、弾は正確に動いていくため、必ず目標の**着地点に到達できる**のです。

### コードの目的：軌道座標の生成

この`GenerateSymmetricParabolaTrajectory`メソッドは、**発射地点（`start`）から着地点（`end`）へ、指定した最高点（`apexOffset`）を通る放物線の軌道（座標のリスト）を生成する**ことを目的としています。このリストを使い、ゲーム内で物体をその軌道に沿って動かすことができます。

---

### 1. 物理と数学の要素

このコードは、放物線運動を支える2つの基本的な物理法則と数学の知識を使っています。

#### 物理の法則：放物線運動
* **水平方向の等速運動**: 重力の影響を受けないため、物体は一定の速度で水平に移動します。
* **鉛直方向の等加速度運動**: 重力によって、物体の上下方向の速度は一定の割合（重力加速度`g`）で変化します。

#### 数学の要素：二次関数とベクトル
* **二次関数**: `y = h0 + Vy * t - 0.5f * g * t * t;`という式は、時間`t`の2乗に比例して高さ`y`が変化する二次関数の形をしています。これが、軌道が放物線になる理由です。
* **ベクトル**: `Vector3`というデータ型を使って、3次元空間の**位置**、**距離**、**方向**を扱っています。特に、`diffXZ`は水平方向の距離を、`dirXZ`はその方向を示しています。

---

### 2. コードの詳細な流れ

このメソッドは、以下のステップで軌道座標のリスト`positions`を生成します。

#### ステップ1：軌道の頂点と距離の決定
* `Vector3 mid = (start + end) * 0.5f;`：発射地点と着地点の中間点を計算します。
* `float apexY = Mathf.Max(start.y, end.y) + apexOffset;`：発射・着地地点のうち高い方に、オフセット値を足して放物線の**最高点の高さ**を決定します。
* `Vector3 diffXZ...` と `float distance...`：水平方向の移動距離`distance`と、その方向`dirXZ`を計算します。

#### ステップ2：初速の計算
このコードの大きな特徴は、**「飛翔時間」を先に仮定する**ことです。
* `float t_half = 1.0f;`：**頂点に到達するまでの時間を1.0秒と仮定**しています。これにより、水平方向の初速`Vxz`と、鉛直方向の初速`Vy`を逆算することができます。
* `float Vxz = halfDistance / t_half;`：**水平速度**を「頂点までの距離 ÷ 頂点までの時間」で計算します。
* `float Vy = (h1 - h0 + 0.5f * g * t_half * t_half) / t_half;`：**鉛直初速**を、「到達したい高さ`h1`」から逆算して求めます。

#### ステップ3：軌道上の各座標の計算と格納
* `float totalTime = t_half * 2.0f;`：頂点までの時間が1秒なので、全体の飛翔時間は2秒と決まります。
* `for`ループで、0秒から`totalTime`までの間を`steps`数に分割し、`t`（現在の時間）を少しずつ増やしながら計算を繰り返します。
* `Vector3 posXZ...`：現在の時間`t`を使って、水平方向の位置を計算します。
* `float y...`：現在の時間`t`を使って、**二次関数の式**から鉛直方向の位置（高さ）を計算します。
* `positions[i] = new Vector3(posXZ.x, y, posXZ.z);`：計算したX, Y, Z座標を`Vector3`として、`positions`配列に順番に格納していきます。

---

## CannonLogical.cs と CannonPhysical.cs の比較：計算か、物理エンジンか？

### 1. 動きの作り方の違い

`CalculateParabolaVelocity`との比較

この2つのメソッドは、同じ放物線運動を扱っていますが、目的とアプローチが異なります。

| | `GenerateSymmetricParabolaTrajectory` | `CalculateParabolaVelocity` |
| :--- | :--- | :--- |
| **目的** | 軌道上の**全座標**を生成する | 到達点に当てるための**初速ベクトル**を計算する |
| **入力** | 頂点の高さオフセット (`apexOffset`) | 初速の合計値 (`speed`) |
| **物理と数学のアプローチ** | 飛翔時間を**仮定**して初速を**逆算**し、二次関数の式で軌道を生成する。 | 初速から**二次方程式の判別式**を解き、必要な角度と時間を**直接計算**する。 |
| **用途** | 物体の動きをスムーズに描画したい場合。 | 物体に一回だけ力を加えて飛ばしたい場合。 |
| **類似点** | どちらもベクトルを使って位置を扱い、最終的に二次関数の法則に基づいて放物線運動を計算する。 |

`GenerateSymmetricParabolaTrajectory`は「最高点の高さを指定して、その軌跡を事前に知りたい」という、よりビジュアルな要求に応える設計です。一方、`CalculateParabolaVelocity`は「この速さで、どう投げれば当たるか？」という、より力学的な要求に応える設計と言えます。

* **`CannonLogical.cs` (計算で動かす)**:
    * 弾の飛ぶ道を、**微積分**に基づいた数学の計算で完全に決定します。まるで、あらかじめ引かれたレールの上を走る電車のように、計算通りに正確に動きます。
    * Unityの物理エンジンは使いません。スクリプトが弾の場所を細かく管理します。

* **`CannonPhysical.cs` (物理エンジンで動かす)**:
    * 弾を打ち出す**最初の速さと方向（初速）だけを計算**します。
    * 物理エンジンが、重力、**エネルギー保存**、**運動量**といった物理法則をシミュレートし、弾を自然に動かしてくれます。途中で何かに当たれば、リアルな反応を示します。

### 2. どんなときに使うのがいい？

* **`CannonLogical.cs` はこんなときに便利**:
    * 「絶対にこのレールの上を通ってほしい！」というように、弾の動きを完璧にコントロールしたいゲーム（パズルゲームなど）。
    * いつも同じ動きをさせたい、演出のための動き。

* **`CannonPhysical.cs` はこんなときに便利**:
    * 「本物みたいにリアルに動かしたい！」というゲーム（シューティングゲームなど）。
    * 弾が壁に当たって跳ね返ったり、風の影響を受けたりするような、**エネルギー保存**などが関わる自然な動きをさせたい場合。

### まとめ

`CannonLogical.cs` は「**時刻表通りに走る電車**」のように、軌道計算に基づいて正確で予測可能な動きをします。一方、`CannonPhysical.cs` は「**実際に空を飛ぶボール**」のように、現実の物理法則に従って、より自然で変化に富んだ動きをします。

どちらのスクリプトを使うかは、ゲームやアプリで「何を一番大切にしたいか」によって選びます。**計算による正確さ**か、それとも**物理シミュレーションによるリアルさ**か、それが大きな違いです。


SLIDE：[https://claude.ai/public/artifacts/4afedbfe-586d-4a7d-a638-22db0a45b11b](https://claude.ai/public/artifacts/4afedbfe-586d-4a7d-a638-22db0a45b11b)
